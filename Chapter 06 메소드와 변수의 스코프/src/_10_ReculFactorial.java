public class _10_ReculFactorial {

	public static void main(String[] args) {
		System.out.println("3 factorial : " + factorial(3));
		System.out.println("2 factorial : " + factorial(12) );
	}

	public static int factorial(int n) {
		if (n == 1)
			return 1;
		else
		    return n * factorial(n-1);
	}
}

/*
자바는 메소드의 재귀호출을 지원한다. 따라서 순서상 재귀호출에 대해서 설명을 할 텐데, 여러분이 이 내용에 부담을 느낀다면,
이 책을 한차례 완전히 공부한 다음에 재귀호출을 공부하는 것이 바람직하다.
메소드의 재귀는 자료구조와 알고리즘의 구현에 유용하게 사용되는 문법이기 때문에 지금 당장 이를 이해하지 못한다고 해서 진도를
나가는데 문제가 되지는 않는다.

■ 수학적 측면에서의 재귀적인(순환적인) 사고
이 세상에는 해결하기 어려운 문제들이 많이 있다. 그런데 다행히도 이러한 문제들의 해결방법을 자료구조와 알고리즘이라는 학문을
통해서 공부할 수 있다. 그리고 이 두 학문에서 빠질 수 없는 개념 중 하나가 바로 '재귀(recursion)'이다. 재귀 또는
재귀적 사고는 어려운 문제를 쉽게 해결하는 열쇠가 되기 때문이다. 따라서 이번에는 자료구조와 알고리즘의 학습에 도움이 될 수 있도록
재귀 메소드의 이해와 정의방법에 대해서 간단히 설명하고자 한다.

우리는 고등학교 수학시간에 팩토리얼(factorial)의 개념을 공부한 적이 있다. 기호 !으로 표현되는 팩토리얼의 계산방식은
다음과 같다.

* 5! = 5 X 4 X 3 X 2 X 1
* 4! = 4 X 3 X 2 X 1
* 3! = 3 X 2 X 1
* 2! = 2 X 1
* 1! = 1

따라서 이 계산식은 다음과 같이 달리 쓸 수도 있다.

* 5! = 5 X 4!
* 4! = 4 X 3!
* 3! = 3 X 2!
* 2! = 2 X 1!
* 1! = 1

여기서 우리는 자바에서 말하는 재귀(순환)을 발견할 수 있다. 팩토리얼의 계산식에 다시 팩토리얼이 등장한 이 상황이 바로 재귀이다.

함수 f의 정의에 함수 f의 실행문이 삽입되어 있다. 이는 수학적으로 전혀 문제되지 않는다. 마찬가지로 자바는 메소드의 재귀를
지원한다. 즉 메소드 f의 몸체(중괄호) 부분에서 메소드 f의 호출문이 삽입되는 것을 허용하고 있다.

■ 재귀적 메소드의 정의
참고로 여러분은 아직 재귀적인 형태의 메소드를 정의해본 경험이 없지만, 힌트로 하여 직접 정의해보는 것은 매우 좋은 시도가 될 수 있다.

실행의 순서와 전달되는 값을 관찰하여 재귀 메소드의 동작방식을 완전히 이해하기 바란다.

여러분은 "아직 실행이 완료되지 않은 메소드를 어떻게 다시 호출할 수 있는가?"라고 질문할 수 있다. 그러나 이는 다음
사실을 알고 나면 이해할 수 있는 부분이다.

"메모리에 저장된 메소드를 구성하는 명령문이 CPU로 이동해서 실행이 된다."

메소드를 구성하는 명령문은 얼마든지 CPU로 이동해서 실행이 가능하므로, 기존에 호출된 메소드가 완료되지 않았다고 해서 호출이
불가능한 것은 아니다. 메소드의 앞 부분을 구성하는 명령문만 반복해서 CPU로 이동시킬 수 있기 때문이다.
*/