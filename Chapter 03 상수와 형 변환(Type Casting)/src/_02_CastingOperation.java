public class _02_CastingOperation {

	public static void main(String[] args) {
		char ch1 = 'A';
		char ch2 = 'Z';
		
		int num1 = ch1;
		int num2 = (int)ch2;
		/* 
		결과적으로는 7행과 차이가 없다. 그러나 형 변환이 발생된다는 사실을 코드상에서 표현한 것이 되기 때문에
		이것이 더 권장하는 코드 구현 방법이다.
		가급적이면 자동으로 형 변환이 발생하는 위치에 명시적으로 형 변환이 됨을 표현하기 바란다. 
		*/
		
		System.out.println("문자 A의 유니코드 값 : " + num1);
		System.out.println("문자 Z의 유니코드 값 : " + num2);
	}

}

/* 
   short num1 = 10;
   short num2 = 20;
   short result = num1 + num2;
   
위의 코드에서 num1과 num2는 short형 변수이다. 따라서 덧셈연산의 과정에서 각각의 변수에 저장되어 있는 값은
int형 데이터로 변환된 다음에야 비로소 연산이 이뤄진다. 그렇다면 int형으로 변환된다는 것은 무엇을 뜻하는 것일까?
이는 short형으로 표현되어 있는 값을 int형으로 다시 표현한다는 의미를 갖는다. 즉 2바이트 변수 num1과 num2는
다음의 형태로 데이터가 저장되어 있는데,
   num1(10) -> 00000000 00001010
   num2(20) -> 00000000 00010100
   
이 데이터들은 덧셈연산 이전에 다음과 같은 형태로 변환이 되어 덧셈연산이 진행됨을 의미한다.
   int형 정수 10 -> 00000000 00000000 00000000 00001010
   int형 정수 20 -> 00000000 00000000 00000000 00010100
   
이것이 바로 형 변환이다.

"에이 형 변환이라는 것이 결국 나머지 2바이트를 전부 0으로 채운 것에 지나지 않네요?"

short와 int는 둘 다 정수를 표현하는 자료형으로서 값을 표현하는 기본원리는 동일하고, 값의 표현에 사용되는 바이트 크기만
다르기 때문에 매우 간단한 방식으로 형 변환이 발생한다. 그러나 int형 정수 1의 비트 열은 다음과 같고
   
   int형 정수 1 -> 00000000 00000000 00000000 00000001
   
float형 실수 1.0의 비트 열은 다음과 같기 때문에(왜 이렇게 되는지는 고민하지 않아도 된다.)

   float형 실수 1.0 -> 00111111 10000000 00000000 00000000

int형 정수 1이 float형 실수 1.0으로 형 변환되면, 다음과 같이 전혀 다른 비트의 열을 구성하는 데이터로 변환이 된다.

   00000000 00000000 00000000 00000001 -> 00111111 10000000 00000000 00000000

형 변환이라는 것은 값의 표현 방식을 바꾸는 것이다. 자바에는 기본적으로 두 가지 형태의 형 변환이 존재한다.
하나는 연산의 대상이 되는 두 피연산자의 자료형이 일치하지 않아서 자동으로 발생하는 형 변환이고,
다른 하나는 명시적으로 형 변환 연산자를 이용해서 발생시키는 형 변환이다.

자동 형 변환에 들어가기에 앞서 CPU의 연산특성에 대해 간단히 설명하고자 한다.

   1.5 + 3
   
문장의 일부로써 위와 같은 덧셈연산이 등장했다고 가정해보자. CPU는 이러한 덧셈연산을 진행하지 못한다. 이유는 간단하다.
CPU는 하나의 연산에 사용되는 두 피연산자의 자료형이 다를 경우, 연산을 진행하지 못하도록 설계되어 있기 때문이다.
2진수의 표현 관점에서 생각해보면 쉽게 이해가 된다. 먼저 int형 정수 1과 int형 정수 2의 합을 2진수의 형태로 계산해보자.

   00000000 00000000 00000000 00000001
  +00000000 00000000 00000000 00000010
  =00000000 00000000 00000000 00000011
  
정수 1과 정수 2는 바이트 크기도 같고 표현방법도 같기 때문에 매우 쉽게 계산이 가능하다.
int형 정수 1과 float형 실수 1.0의 합도 계산해 보겠는가?

   00000000 00000000 00000000 00000001
  +00111111 10000000 00000000 00000000
  =???????? ???????? ???????? ????????
  
위의 2진수는 정수 1을, 아래의 2진수는 실수 1.0을 표현해 놓은 것이다. 그렇다면 이는 어떻게 계산해야 하겠는가?
변환의 과정을 거치지 않는 계산방법을 여러분이 제시해 줄 수 있겠는가?
이렇듯 CPU뿐만 아니라 우리 인간에게도 표현방식이 다른 두 데이터를 가지고 연산하는 것은 쉽지 않은 일이다.

이러한 유형의 계산을 위해서는 표현법을 하나로 통일시킨 다음에 계산을 해야 한다. 우리 인간이 2진수 정수와 16진수 정수의
덧셈을 할 때, 둘 다 10진수로 변환을 해서 덧셈을 하거나 16진수를 2진수로 바꿔서 덧셈 하듯이, CPU도 덧셈을 할 수 있도록
표현법을(자료형을) 하나로 통일시켜 줘야 한다. 때문에 자바는 '자동 형 변환'이라는 과정을 통해서 CPU가 연산을 할 수 있도록
자료형을 하나로 일치시켜 준다.

자동으로(프로그래머가 별도의 형 변환 명령을 내리지 않아도) 형 변환이 발생하는 대표적인 사례는 다음과 같다.

   double num1 = 20;
   
선언된 변수 num1은 double형이다. 따라서 이 변수에 저장될 데이터도 double형이어야 한다. 그런데 대입의 대상이
되는 값은 int형 정수 20이다.따라서 이 경우에는 int형 정수 20이 double형 실수 20.0으로 자동 형 변환되어
변수 num1에 저장이 된다. 그러나 다음의 경우에는 자동으로 형 변환이 발생하지 않는다.

   int num2 = 20.5;
   
20.5는 8바이트 double형 상수이다. 그런데 이를 4바이트 int형 변수 num2에 저장하려 하고 있다.
이 경우에도 double형 데이터 20.5가 int형 데이터로 변환될까? 변환되지 않는다.(그래서 컴파일 오류가 발생한다.)
왜냐하면 데이터의 손실이 발생하기 때문이다. 이처럼 자바에서는 데이터의 손실이 발생하지 않거나, 발생하더라도
그 손실이 제한적인 경우에만 자동 형 변환을 허용한다. 다음은 자바에서 정의하고 있는 자동 형 변환 규칙이다.

   byte -> short ->
            char -> int -> long -> float -> double

화살표 방향으로는 자동으로 형 변환이 발생한다. 즉 int형 데이터는 필요 시 long, float, double형으로 자동 형 반환된다.
그리고 모든 데이터는 필요 시 double형으로 자동 형 변환된다.

   float num1 = 10;
   
위 문장의 왼편에는 float형 변수가 선언되었다. 그리고 오른편에는 int형 상수가 선언되었다.
그런데 int는 float형으로 자동 형 변환이 가능하기 때문에, 10이 10.0f으로 형 변환되어 num1에 저장된다.

   double num2 = 3.5f + 12;
   
위 문장에서는 총 두 번의 형 변환이 발생하는데, 첫 번째는 덧셈연산 과정에서 발생한다.
이러한 경우에(두 피연산자의 자료형이 일치하지 않는 경우에) 자바는 CPU가 연산할 수 있도록 자동으로 형 변환을 발생시킨다.
그렇다면 어떠한 자료형을 기준으로 일치를 시켜야 할까? int는 float로 자동 형 변환이 가능하지만, float는 int로
자동 형 변환이 불가능하다. 따라서 이러한 경우네는 int형 데이터 12가 float형으로 변환이 되어서 덧셈 연산이 진행된다.

   3.5f + 12.0f;

덧셈의 결과는 15.5f이므로 이제 남은 것은 변수 num2에 저장하는 일이다. 즉 다음 문장이 처리되어야 한다.

   double num2 = 15.5f;

그런데 이 경우에도 자료형이 일치하지 않아서 문제가 발생한다. 다행히도 float형은 double형으로 자동 형 변환이
가능하기 때문에 15.5f는 double형 상수 15.5로 형 변환되어 변수 num2에 저장이 된다.

참고
- 자동 형 변환 규칙에서의 long과 float
자동 형 변환 규칙의 순서상 8바이트로 표현되는 long형보다 4바이트로 표현되는 float형이 더 높은 위치에 있다.
이는 자바의 자동 형 변환 규칙이 바이트 크기가 아닌, 값의 표현 범위를 기준으로 정의되었기 때문이다.

자동 형 변환 규칙에 위배되는 상황임에도 불구하고 형 변환이 필요한 경우에는 '명시적 형 변환'을 통해서 형 변환이 이뤄지도록
문장을 구성할 수 있다. 다음 문장은 명시적 형 변환 방법을 보이고 있다.

   int num = (int)3.15; // 3.15를 int형으로 형 변환

위 문장에서는 double형 상수 3.15를 int형으로 명시적 형 변환하고 있다. 물론 이 과정에서 데이터의 손실이 발생하지만,
(소수점 이하의 데이터가 잘려나간다.) 컴파일 오류의 발생 없이 형 변환이 이루어진다. 한가지 예를 더 보겠다.

   long num1 = 2147483648L;
   int num2 = (int)num1;
   
실수형 데이터를 정수형 데이터로 형 변환하는 경우에는 소수점 이하가 잘려나가지만, 위와 같이 자료형만 다른 두 정수형 데이터
사이에서 형 변환을 하는 경우에는 상위 바이트가 잘려나가는 방식으로 형 변환이 이뤄진다.
따라서 변수 num1의 상위 4바이트를 제외한 나머지 4바이트가 변수 num2에 채워지게 된다.
물론 다음과 같이 int형 데이터를 long형으로 변환하는 경우에는, 반대로 0으로 채워진 4바이트 데이터가 상위 바이트에
더해지게 된다. 따라서 변수 num4에는 num3에 저장된 값과 동일한 값이 저장된다.

   int num3 = 100;
   long num4 = (long)num3;
   
그리고 형 변환도 값을 반환하는 하나의 연산이다. 즉 위의 두 경우에는 num1과 num3에 저장된 값이 변경되는 것이 아니라,
num1과 num3에 저장된 값을 참조하여 int형, 그리고 long형으로 변환된 새로운 값을 만들어서 변수 num2, num4에
저장하는 것이다.
*/
