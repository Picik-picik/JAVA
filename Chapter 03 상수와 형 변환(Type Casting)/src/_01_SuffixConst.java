public class _01_SuffixConst {

	public static void main(String[] args) {
		double e1 = 7.125;
		float e2 = 7.125F;
		
		long n1 = 10000000000L;
		long n2 = 150;
		
		System.out.println(e1);
		System.out.println(n1);
		System.out.println(e2);
		System.out.println(n2);
	}

}

/*
   int num = 1 + 5;
   System.out.println(2.4 + 7.5);
   
위의 두 문장에서는 1, 5, 2.4, 7.5 총 네 개의 상수가 사용되었다.
변수와 마찬가지로 메모리 공간에 값이 저장은 되지만, 변수와 달리 저장된 값의 변경은 불가능하다.

CPU를 통한 연산의 대상이 되기 위해서는 상수도 메모리 공간 어딘가에 저장이 되어 있어야 한다.
이렇게 선언이 되는 상수의 특징은 다음과 같다.

* 이름이 없다.
* 이름이 없으므로 메모리에 저장된 상수의 값을 변경시킬 수 없다.

예를 들어 메모리 주소 100번지와 200번지에 각각 1과 5가 저장되었다고 가정해 보자.
100번지와 200번지에 저장된 값을 각각 2와 7로 변경시킬 수 있겠는가? 없다!
변수는 메모리 공간의 접근을 위한 이름이 존재하지만, 상수는 이름이 없기 때문에 메모리 공간의 접근 자체가 불가능하다.

자바의 기본 자료형은 변수, 상수에 상관없이 데이터를 표현하는 기준이 된다. 따라서 상수도 기본 자료형을 기준으로
표현(저장)되어야 한다.

"기본적으로 모든 정수형 상수는 int형으로 표현 및 저장합니다."
"기본적으로 모든 실수형 상수는 double형으로 표현 및 저장합니다."

따라서 앞서 보인 코드에서 1과 5는 메모리 공간에 4바이트씩 할당되어 저장이 되고,
2.4와 7.5는 메모리 공간에 8바이트씩 할당되어 저장이 된다.

참고
- 상수를 가리켜 리터럴(literal)이라고도 합니다.
자바에서 말하는 상수는 자료형을 기반으로 메모리 공간에 저장이 되기 때문에, 그 자체로도 데이터로 인정을 해야 한다.
그래서 상수를 가리켜 리터럴이라고도 표현을 하는데, 리터럴과 상수는 거의 동일한 의미로 사용이 된다.

   int num = 10000000000;

숫자 10000000000가 int형의 표현범위를 넘어서기 때문에 에러를 발생시킨다. 그렇다면 다음과 같이 문장을 변경하면 괜찮을까?

   long num = 10000000000;
  
숫자 10000000000은 long형 변수에 저장이 가능하다. 하지만 이번에도 컴파일러는 에러를 발생시킨다.
이 때 발생하는 에러 메시지를 적절히 해석하면 다음과 같다.

"정수 10000000000 이거 너무 커!"

long형 변수에 저장이 가능한 값임에도 불구하고 에러 메시지를 띄우는 이유는
자바는 상수의 자료형 검사에 엄격하다. 정수형 상수는 무조건 int형으로 표현된다고 하지 않았는가?
따라서 이 커다란 숫자 역시 int형으로 표현이 가능한지를 먼저 판단해본다. 이 값을 저장한 변수 num이 long형인지
아닌지는 그 다음의 문제일 뿐이다. 따라서 이러한 경우에는 이 큰 수를 int형이 아닌 long형으로 표현해 달라고 명시적으로
선언을 해야 한다.

   long num1 = 10000000000L;
   
숫자 뒤에 붙는 접미사 L은 다음의 의미를 지닌다. 그리고 이러한 접미사는 대소문자를 가리지 않으므로 소문자 l을 써도 된다.

"이 정수를 long형으로 표현해 주세요!"

즉 자바는 상수의 크기를 기준으로 자료형을 결정짓지 않는다. 정수는 int형, 실수는 double형으로 표현이 되기 때문에
그 이외의 다른 자료형으로 값을 표현해야 한다면, 그에 따른 약속된 접미사를 사용해야 한다.

   float num2 = 12.45;
   
자바는 실수(실수형 상수)를 무조건 double형으로 표현하기 때문에 12.45가 double형으로 표현이 가능한 값인지를
먼저 검사한다. 문제가 없음이 확인되었다면 이번에는 변수 num2에 저장이 가능한지를 확인하게 되는데, 이 경우에는
float형 변수에 저장해야 하기 때문에 컴파일 에러가 발생한다.

12.45는 float형 변수에도 저장이 가능한 값이지만 자바 컴파일러는 이 상황에서 값의 크기를 기준으로 판단하지 않고,
값의 표현에 사용되는 바이트 크기를 기준으로 판단을 한다. 따라서 8바이트 double형 상수의 값을 4바이트 float형 변수에
저장하는 문장에서는 컴파일 에러가 발생한다. 때문에 이 문장을 컴파일하기 위해서는 다음과 같이 접미사를 사용해야 한다.

   float num2 = 12.45F;
   
접미사 F는 해당 실수를 float형으로 표현하라는 의미가 담겨있다. 따라서 12.45F 또는 12.45f는 float형
4바이트 데이터로 인식 및 표현이 된다.

참고
- byte와 short형 상수의 표현을 위한 접미사는 존재하지 않습니다.
숫자 150은 int형 상수이고, 150L은 long형 상수이다. 그렇다면 byte형과 short형 상수는 어떻게 표현을 할까?
아쉽게도(알고 보면 아쉬운 일도 아니다) 이 둘에 대한 상수의 표현을 자바는 지원하지 않고 있다. 상수는 대부분
연산 및 변수의 초기화를 위해서 사용이 되는데, 자바는 정수에 대한 산술연산을 int형 기반으로 처리하기 때문에,
사실상 byte형과 short형으로 상수를 표현할 일이 없다. 그리고 byte형 변수와 short형 변수에 대해서는 다음과 같이
int형 상수 기반의 초기화를 허용하기 때문에 더더욱 byte형, short형으로 상수를 표현할 일이 없다고 이야기 할 수 있다.
   byte num1 = 20;   // 허용
   short num2 = 50;  // 허용
   
물론 이는 정수 20과 50이 byte형으로, short형으로 각각 표현이 가능하기 때문에 허용되는 것이다.
만약에 byte형으로 표현이 불가능한 값을 변수 num1에 저장하려 든다면 컴파일 에러가 발생하게 된다.
*/