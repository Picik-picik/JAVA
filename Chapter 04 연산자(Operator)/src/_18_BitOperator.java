public class _18_BitOperator {

	public static void main(String[] args) {
		int num1 = 5;   // 00000000 00000000 00000000 00000101
		int num2 = 3;   // 00000000 00000000 00000000 00000011
		int num3 = -1;  // 11111111 11111111 11111111 11111111
		
		System.out.println(num1 & num2);
		/*
		num1과 num2의 & 연산결과는 0으로 채워지는 상위 3바이트를 생략하면 00000001이다.
		즉 연산결과는 정수 1이다.
		*/
		System.out.println(num1 | num2);
		/*
		num1과 num2의 | 연산결과는 0으로 채워지는 상위 3바이트를 생략하면 00000111이다.
		즉 연산결과는 정수 7이다.
		*/
		System.out.println(num1 ^ num2);
		/*
		num1과 num2의 ^ 연산결과는 0으로 채워지는 상위 3바이트를 생략하면 00000110이다.
		즉 연산결과는 정수 6이다.
		*/
		System.out.println(~num3);
		/*
		-1로 초기화 된 변수 num3의 모든 비트는 1로 채워진다.(2의 보수 표현법 참조) 따라서 num3에 대한 ~연산의 결과는
		모든 비트가 0으로 채워지는 정수 0이다.
		*/
	}

}

/*  
■ 비트 연산자 : &, |, ^, ~
비트 연산자의 연산 특성에 대해서 이해하였으니, 이제 & 연산자부터 시작해서 비트 연산자들을 하나씩 살펴보기로 하자.
& 연산자(비트 AND 연산자)는 && 연산자(논리 AND 연산자)와 유사하다. && 연산자가 두 피연산자 모두 true일 때에만
true를 반환한다면, & 연산자는 두 비트가 모두 1일 때에만 1을 반환하여 하나의 연산결과를 구성한다.
다음은 & 연산자에 대한 진리 표(truth table)이다.

비트 A   비트 B   비트 A & 비트 B
1      1       1 
1      0       0
0      1       0
0      0       0

이어서 소개할 | 연산자(비트 OR 연산자)는 || 연산자(논리 OR 연산자)와 유사하다.
|| 연산자가 두 피연산자 중 하나만 true를 반환한다면, | 연산자는 두 비트 중 하나만 1이라도 1을 반환하여 하나의
연산결과를 구성한다. 다음은 | 연산자에 대한 진리 표이다.

비트 A   비트 B   비트 A | 비트 B
1      1       1 
1      0       1
0      1       1
0      0       0

마지막으로 두 비트의 값이 서로 다른 경우에만 1을 반환하는 ^ 연산자(비트 XOR 연산자)와 1은, 0으로, 0은 1으로
반전시키는 ~ 연산자(비트 NOT 연산자)에 대한 진리 표를 제시하겠다.

비트 A   비트 B   비트 A ^ 비트 B
1      1       0 
1      0       1
0      1       1
0      0       0

비트   ~비트
1   0
0   1
*/