public class _04_Comp {

	public static void main(String[] args) {
		double e = 3.1;
		e += 2.1;
		e *= 2;
		/*
		이 문장은 e = e * 2와 동일하다. 그런데 이 상황에서 곱셈 연산자의 두 피연산자 자료형이 일치하지 않는다.
		따라서 자동 형 변환 규칙에 의해 int형 정수 2가 double형 실수 2.0으로 변환이 되어서 곱셈이 진행된다.
		즉 이 문장에서는 복합 대입 연산자의 왼편에 있는 e를 기준으로 형 변환이 발생한다.
		*/
		
		int n = 5;
		n *= 2.2;
		/* 
		이 문장은 n = n * 2.2와 동일하다. 그렇다면 형 변환은 어떻게 진행이 될까?
		n이 int형이므로 형 변환 규칙에 의해서 n의 값이 double형으로 변환이 되어 * 연산이 진행된다.
		그리고 그 결과가 다시 변수 n에 저장되어야 하는데, 연산의 결과는 double형 상수 11.0이고
		변수 n은 int형이므로, 여기서 다시 11.0이 int형 상수 11로 형 변환이 되어 변수 n에 저장된다.
		*/
		
		System.out.println(e);
		System.out.println(n);
	}

}

/*
■ 복합(Compound) 대입 연산자
이번에 소개할 이항 연산자는 복합 대입 연산자이다. 이는 대입 연산자가 다른 연산자와 묶여서 정의된 형태의 연산자로서,
우선순위 15위에 등록되어 있는 연산자들이다.
이중에서 대입 연산자와 산술 연산자가 합해져서 만들어진 복합 대입 연산자는 총 다섯 개로써 각각의 의미는 다음과 같다.

a = a + b ← 동일 연산 → a += b
a = a - b ← 동일 연산 → a -= b
a = a * b ← 동일 연산 → a *= b
a = a / b ← 동일 연산 → a /= b
a = a % b ← 동일 연산 → a %= b

이에 대한 이해를 위해서는 먼저 다음과 같은 문장도 성립이 됨을 이해하고 있어야 한다.

   num = num + 5;
   
하나의 문장 안에 num이 두 번 등장하기 때문에 이상하게 생각될 수도 있다.
그러나 덧셈연산이 먼저 진행되고, 그 때 계산된 결과 값으로 대입연산이 진행된다고 생각하면 이상할 것도 없다.
변수 num에 2가 저장되어 있었다면 덧셈의 결과는 7이 된다. 따라서 위의 문장을 덧셈연산 이후에 다음과 같이 된다고 볼 수 있다.

   num = 7;

결국 변수 num에는 7이 저장되는데, 결과적으로 변수 num에 저장된 값을 5 증가시킨 꼴이 되었다.
그럼 이제 위 그림을 참조하여 다음 식을 분석해 보자.

   num *= 9;
   
이는 다음 식을 간단히 표현한 것이다. 결론적으로 변수 num에 저장된 값이 9배 증가되었다.

   num = num * 9;
   
여러분은 위 그림을 통해서 복합 대입 연산자의 구성 원리를 이해해야 한다. 그러면 아직까지 설명되지 않은 연산자들을 기반으로
구성이 되는 복합 대입 연산자들에 대해서도 이해가 가능하다.
이전에 작성한 표를 보면 위 그림에서 보인 연산자들 이외에도 다음의 복합 대입 연산자들이 존재함을 알 수 있다.

&=, ^=, |=, <<=, >>=, >>>=

그렇다면 이들이 의미하는 바는 무엇일까? 우리는 아직 &, ^, >>> 등의 연산자를 알지 못한다. 그러나 다음의 문장들이 의미하는 바가

   A &= B;
   A ^= B;
   A >>>= B;

각각 다음의 문장들과 동일함은 알 수 있다.

   A = A & B;
   A = A ^ B;
   A = A >>> B;
   
따라서 여러분은 이후에 &, ^, >>> 등의 연산자들이 지니는 기능만 이해하면, 모든 복합 대입 연산자들에 대해서 이해하고
활용할 수 있을 것이다.

당분간은 e += 2.1을 e = e + 2.1로 바꿔서 이해하자. 그러나 습관이 되면, 이러한 과정을 거치지 않고
"변수 e에 저장된 값을 2.1 증가시키는 연산"으로 이해하게 되는데, 이것이 보다 바람직한 해석 방법임을 기억하자.

참고
- 하나의 연산자가 두 번의 자동 형 변환을 발생시켰다.
예제 Comp.java의 9행에 있는 n *= 2.2는 매우 재미있는 연산문이다. 왜냐하면 하나의 피연산자가 두 번의 자동 형변환을
일으켰기 때문이다. 두 번의 형 변환이 발생하는 이유를 이해하기 위해서는 소스해설에서 설명하고 있듯이 n = n * 2.2으로
바꿔서 분석을 해야 한다. 단! 곱셈연산 이후 대입의 과정에서 자료형의 불일치로 인한 문제가 발생은 하지 않지만, 이는
어디까지나 *= 연산의 일부이기 때문에 컴파일 에러를 발생시키지 않는다는 사실에도 주목할 필요가 있다.
*/