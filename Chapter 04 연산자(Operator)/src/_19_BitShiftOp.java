public class _19_BitShiftOp {

	public static void main(String[] args) {
		System.out.println(2 << 1);   // 4 출력
		System.out.println(2 << 2);   // 8 출력
		System.out.println(2 << 3);   // 16 출력
		
		System.out.println(8 >> 1);   // 4 출력
		System.out.println(8 >> 2);   // 2 출력
		System.out.println(8 >> 3);   // 1 출력
		
		System.out.println(-8 >> 1);  // -4 출력
		System.out.println(-8 >> 2);  // -2 출력
		System.out.println(-8 >> 3);  // -1 출력
		
		System.out.println(-8 >>> 1); // 2147483644 출력
	}

}

/*  
■ 비트 쉬프트(Shift) 연산자 : <<, >>, >>>
비트 쉬프트 연산자는 피연산자의 비트 열을 왼쪽 또는 오른쪽으로 이동시키는 연산자이다. 이러한 비트 쉬프트 연산자들도
두 개의 피연산자가 필요한 이항 연산자이며, 비트 연산자들과 마찬가지로 피연산자는 모두 정수이어야 한다.
자바는 총 3개의 비트 쉬프트 연산자를 제공하는데, 이들의 기능을 정리하면 다음과 같다.

연산자    연산자의 기능                                                          결합방향
<<        피연산자의 비트 열을 왼쪽으로 이동                                       →
          이동에 따른 빈 공간은 0으로 채움
          예) n << 2;
           → n의 비트 열을 두 칸 왼쪽으로 이동 시킨 결과 반환
>>        피연산자의 비트 열을 오른쪽으로 이동                                     →
          이동에 따른 빈 공간은 음수의 경우 1, 양수의 경우 0으로 채움
          예) n >> 2;
           → n의 비트 열을 두 칸 오른쪽으로 이동 시킨 결과 반환
>>>       피연산자의 비트 열을 오른쪽으로 이동                                     →
          이동에 따른 빈 공간은 0으로 채움
          예) n >>> 2;
           → n의 비트 열을 두 칸 오른쪽으로 이동 시킨 결과 반환

변수 A, B가 존재할 때, 다음 형식으로 문장을 구성할 수 있다.(A와 B는 상수도 될 수 있다.)

   int num A << B;
   
그리고 이는 다음과 같은 의미를 지닌다.

"A의 비트 열을 B만큼 왼쪽으로 시켰을 때, 얻게 되는 정수 값을 변수 num에 저장해라!"

위 예제 4~6행에서는 정수 2의 비트 열을 왼쪽으로 각각 1, 2, 3 칸씩 이동시킨 결과를 출력하고 있다.
그렇다면 얼마가 출력될지 먼저 계산해 보자. 단 int형으로 표현되는 정수 2의 상위 3바이트는 0으로 채워지니 이를 제외한
나머지 부분만을 가지고 계산을 진행해 보겠다.

정수 2 -> 00000010 -> 정수 2
2 << 1 -> 00000100 -> 정수 4
2 << 2 -> 00001000 -> 정수 8
2 << 3 -> 00010000 -> 정수 16

어렵지 않게 계산이 가능하다. 그리고 여기서 중요한 결론 하나를 내릴 수 있다.

"왼쪽으로 비트 열 이동은 2의 배수의 곱으로 이어진다."

즉, 왼쪽으로 비트 열을 1칸 이동시키면 이는 2를 곱하는 꼴이 된다. 그리고 왼쪽으로 비트 열을 2칸 이동시키면 이는 4를 곱하는
꼴이 된다. 이렇듯 왼쪽으로 비트 열을 n칸 이동시키면, 이는 2의 n승을 곱하는 결과로 이어지는데, 이것이 바로 2진수 정수의
특성이다. 만약에 이 현상이 이해되지 않는다면 임의의 정수를 가지고 여러분이 직접 확인해 보자. 2진수 정수의 비트 열을 왼쪽
으로 한 칸씩 이동시킬 때 마다 정말로 값이 두 배가 증가가 되는지를 말이다. 이를 확인하였다면 여려분은 더불어서 다음의 결론도
내릴 수 있다.

"오른쪽으로 비트 열 이동은 2의 배수의 나눗셈으로 이어진다."

비트 열을 왼쪽으로 이동시키면 2의 배수의 곱으로 이어지니, 오른쪽으로 이동시키면 2의 배수의 나눗셈으로 이어지는 것은 당연한
일이다. 즉 오른쪽으로 비트 열을 n칸 이동시키면, 이는 2의 n승으로 나누는 결과로 이어진다. 따라서 위 예제의 8~10행의
출력 결과는 별도의 계산 과정이 없어도 4, 2, 1이 출력됨을 쉽게 판단할 수 있다.
그렇다면 지금 설명한 비트 쉬프트 연산에 따른 값의 증가 및 감소는 음의 정수에도 동일하게 적용이 될까? << 연산자와 >> 연산자를
이용해서 비트 열을 이동시키면, 대부분의 경우에는 동일하게 적용이 된다. 왜냐하면 << 연산자와 >> 연산자는 값의 부호를 결정
하는 MSB(가장 왼쪽 비트)를 그대로 유지하기 때문이다. 즉 MSB가 1이면 >> 연산에 따른 빈 공간을 1로 채우고, MSB가
0이면 >> 연산에 따른 빈 공간을 0으로 채운다. 그러나 >>> 연산자는 이동에 따른 빈 공간을 무조건 0으로 채우기 때문에,
위 예제 16행의 출력결과가 보이듯이 음수의 경우 2의 배수와 전혀 상관없는 값이 만들어진다는 사실을 기억하자.

참고
- 비트 연산자 그리고 비트 쉬프트 연산자의 유용성
CPU에게 있어서 곱셈과 나눗셈은 매우 부담이 되는 작업이지만, 비트를 이동시키는 연산은 전혀 부담되지 않는 작업이다.
따라서 CPU의 연산능력이 약한 소형 컴퓨터상에서 동작하는 프로그램의 구현에서는 2의 배수 단위로 값을 증가 및 감소시켜야 하는
경우에 실제로 비트 쉬프트 연산자를 사용하기도 한다. 그리고 비트 연산자와 비트 쉬프트 연산자는 그 활용의 범위를 한정 지을 수
없을 만큼 다양하게 활용이 된다. 때문에 프로그래머의 구현 능력을 판단하는 기준 중 하나로 비트 쉬프트 연산자의 활용 능력을
꼽는 분들도 있다.
*/
