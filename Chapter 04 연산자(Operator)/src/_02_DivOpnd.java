public class _02_DivOpnd {

	public static void main(String[] args) {
		System.out.println("정수형 나눗셈 : " + 7 / 3);
		System.out.println("실수형 나눗셈 : " + 7.0f / 3.0f);
		System.out.println("형 변환 나눗셈 : " + (float)7 / 3);
		/*
		정수 7을 float형으로 형 변환하고 있다. 따라서 정수 7은 7.0f가 되어 7.0f / 3이 진행된다.
		그런데 두 피연산자의 자료형이 일치하지 않으므로 형 변환 규칙에 의해 3이 3.0f로 자동 형 변환 된다.
		결국 7.0f / 3.0f가 진행이 되어 실수형 나눗셈의 결과 2.3333333이 출력된다.
		*/
	}

}

/* 
■ 나눗셈 연산자와 나머지 연산자에 대해서 보충합니다.
예제 ArithOp.java와 관련해서 추가적인 설명이 조금 더 필요하다. 이 예제의 13행에는 다음 문장이 존재한다.

   System.out.println("나눗셈 결과 : " + n1 / n2);
   
n1은 7이고 n2는 3이니, 나눗셈의 결과는 다음과 같다고 할 수 있다.

2.333333···

또는 다음과 같이 이야기 할 수도 있다.

"몫은 2이고 나머지는 1이다."

이 둘의 차이점을 알겠는가? 둘 다 답이 될 수 있다. 다만 나머지가 존재하는 방식은 정수형 나눗셈의 결과이고,
나머지가 존재하지 않고 실수의 형태로 결과를 보이는 방식은 실수형 나눗셈의 결과일 뿐이다.
그렇다면 실행결과만 보고 다음과 같은 결론을 내릴 수도 있을 것이다.

"아 / 연산자는 정수형 나눗셈을 하는구나!"

그러나 이는 잘못된 관찰결과다. 연산의 방식은 피연산자의 자료형에 따라서 결정이 된다. 두 개의 피연산자가 모두 정수이면
정수형 나눗셈을 하고, 두 개의 피연산자가 실수이면 실수형 나눗셈을 한다.

위 예제에서는 정수 7을 float형으로 형 변환하고 있는데, 이 때에 사용되는 소괄호는 연산의 순서를 지정하기 위해서
사용되는 소괄호와 다르다. 연산의 순서를 지정하기 위해서 사용되는 소괄호는 연산자가 아닌, 연산의 순서를 구분하기
위한 '구분자'라고 하지 않았는가? 하지만 형 변환에 사용되는 소괄호는 구분자가 아닌 연산자이다.
우선순위 3위에 등록되어 있는 연산자임을 확인할 수 있다.
*/