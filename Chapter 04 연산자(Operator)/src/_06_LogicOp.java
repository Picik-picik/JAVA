public class _06_LogicOp {

	public static void main(String[] args) {
		int num1 = 10, num2 = 20;
		
		boolean result1 = (num1 == 10 && num2 == 20);
		/* 
		소괄호 부분을 먼저 보자. 여기에는 == 연산자와 && 연산자가 존재하는데, 우선순위는 == 연산자가 더 높다.
		따라서 == 연산의 결과를 가지고 && 연산을 진행하게 된다.
		*/
		boolean result2 = (num1 <= 12 || num2 >= 30);
		/* 
		여기서는 소괄호 안에 <=, >= 그리고 || 연산자가 존재하는데, 이중에서 || 연산자의 우선순위가 제일 낮다.
		따라서 <=, >= 연산의 결과를 가지고 || 연산을 진행하게 된다.
		*/
		
		System.out.println("num1 == 10 그리고 num2 == 20 : " + result1);
		System.out.println("num1 <= 12 또는 num2 >= 30 : " + result2);
		
		if (! (num1 == num2))
			System.out.println("num1과 num2는 같지 않다.");
		else
			System.out.println("num1과 num2는 같다.");
		/*  
		이 코드 블록도 앞서 보인 if~else문을 바탕으로 구성되었다. 그런데 if의 소괄호 안에는 == 연산의 결과에
		!연산을 하도록 구성되어 있다. 따라서 이는 == 연산결과를 뒤집는, 즉 true는 false, false는 true로
		바꾸는 결과로 이어진다.
		*/
	}

}

/* 
■ 논리 연산자(&&, ||, !)
논리 연산자 연시 true 또는 false를 반환하는 연산자로써 AND(논리곱), OR(논리합), NOT(논리부정)을 의미하는
연산자로 구성되어 있다.

연산자    연산자의 기능                                  결합방향
&&    예) A && B                                        →
      A와 B 모두 true이면 연산결과는 true (논리 AND)
||    예) A || B                                        →
      A와 B 둘 중 하나라도 true이면 연산결과는 true (논리 OR)
!     예) !A                                            ←
            연산결과는 A가 true이면 false, A가 false이면 true (논리 NOT)
            
위 연산자들 모두 연산의 결과로 true 또는 false를 반환한다. 그리고 이들 연산자의 연산결과를 나타낸 표를 가리켜
'진리 표(truth table)'라 하는데, 이 표를 보면 논리연산의 결과를 한눈에 확인할 수 있다.

피 연산자 1(OP1)   피 연산자 2(OP2)   연산결과(OP1 && OP2)
true              true               true
true              false              false
false             true               false
false             false              false

피 연산자 1(OP1)   피 연산자 2(OP2)   연산결과(OP1 || OP2)
true              true               true
true              false              true
false             true               true
false             false              false

피 연산자(OP)   연산결과(!OP)
true           false
false          true

참고
- !연산자는 단항 연산자입니다.
연산자의 수가 많기 때문에 필자는 이항 연산자와 단항 연산자 그리고 비트와 관련이 있는 연산자를 나눠서 설명하고 있다.
그러나 이는 설명의 편의를 위한 임의적인 구분일 뿐, 연산자를 구분하는 절대적인 기준은 아니다.
예를 들어서 비트와 관련이 있는 연산자중에는 단항 연산자도 있고 이항 연산자도 있다. 그리고 지금 설명하고 있는
논리 연산자 중에도 단항 연산자 !가 존재한다.

true와 false를 피연산자로 연산을 진행하는 것이 논리 연산자라 할 수 있다. 물론 true와 false가 직접 등장하지는 않는다.
true 또는 false를 판단(반환)하는 관계 연산문이 대신 등장하는 것이 보다 일반적이다.

■ 연산자 우선순위에 근거해서 판단할 일이냐!
바로 앞에서 보인 예제 LogicOp.java의 다음 연산문을 보면서 필자는 연산자의 우선순위를 근거로 == 연산자가 먼저 진행된다고
설명하였다.

   num1 == 10 && num2 == 20
   
연산자 우선순위가 잘 정리되어 있어서 이렇게 설명을 해도 문제는 되지 않는다. 그러나 이 연산문은 연산자의 우선순위에 의해서
== 연산이 먼저 진행되는 것은 아니다. 예를 들어서 && 연산자의 우선순위가 == 연산자보다 상대적으로 높다고 가정해보자.
그렇다면 위 문장은 && 연산자부터 먼저 연산이 되겠는가? 먼저 연산을 시도하려 들 수는 있을 것이다. 그러나 이내 다음과 같은
판단이 이뤄진다.

"어라? && 연산자의 피연산자로 true와 false가 아닌 비교 연산자가 등장해 있네? 그럼 비교 연산자의 연산결과를 가지고
&& 연산을 진행해야 하겠군!"

위의 문장에서는 이래저래 == 연산이 먼저 진행될 수 밖에 없다. 이는 && 연산자의 피연산자 위치에 == 연산자가 등장했기
때문이다. 즉 이 문장에서 && 연산자와 == 연산자는 대등한 위치에 놓여있지 않다.
&& 연산자의 피연산자로 == 연산자가 놓여있는 것이다. 따라서 이러한 경우에는 연산자의 우선순위에 상관없이
== 연산자가 먼저 진행된다. 조금 혼란스러울 수 있어서 다른 연산문을 가지고 비교를 해 보겠다.

   3 + 5 X 7
   
이 문장의 경우 +와 X는 서로 대등한 위치에 놓여있다. 3 + 5의 연산결과도 X 연산자의 피연산자가 될 수 있고,
5 X 7의 결과도 + 연산자의 피연산자가 될 수 있기 때문이다. 따라서 이러한 경우에는 연산자의 우선순위와 결합방향을
가지고 연산의 순서를 결정하면 된다. 하지만 다음 문장은 상황이 다르다.

   num1 == && num2 == 20

이 상황에서는 && 연산의 결과가 == 연산자의 피연산자가 될 수 없다. 하지만 == 연산의 결과는 && 연산자의 피연산자가
될 수 있다. 때문에 연산자의 우선순위에 상관없이 == 연산자가 먼저 진행되어야 한다.

참고
- 결과적으로 같은 것 아니냐?
여러분은 "결과적으로 같은 것 아니냐"라고 물을 수 있고, 때문에 필자도 처음에는 연산자의 우선순위를 근거로 설명을 한 것이다.
하지만 연산의 순서가 결정되는 기본 원칙의 이해를 바라는 마음에서 몇 자 적은 것이니, 자바라는 큰 대어를 잡는데 있어서 불필요한
내용으로 느껴진다면 이후에 참조할 내용으로 남겨둬도 좋다.
*/
